name: CI

on:
  workflow_dispatch:
  push:
    branches: [ci-v3]
  # pull_request:
  #   branches: [master]
  #   types: [opened, reopened]

jobs:       
  changes:
    runs-on: ubuntu-latest
    outputs:
      service_build_list: ${{steps.build_list.outputs.service_build_list}}
      services: ${{ steps.filter-services.outputs.array }}
      all_changed_files: ${{ steps.filter.outputs.array }}
      packages: ${{ steps.resolved-packages.outputs.packages }}
    steps:
      - uses: actions/checkout@v2
        with:
          fetch-depth: 0
      - name: get changed files (not pr)
        if: github.event_name != 'pull_request'
        id: changed-files-not-pr
        run: |
          changed_files=$(git diff --name-only `git merge-base origin/master HEAD`)
          while IFS= read -r changed_file ; do 
            echo "changed_file: $changed_file"
            all_changed_files=$all_changed_files+",$changed_file"
          done <<< "$changed_files"
          all_changed_files="${all_changed_files:1}"
          echo "all_changed_files: $all_changed_files"
          echo "::set-output name=all_changed_files::$diff"
      - name: get changed files (pr)
        id: changed-files-pr
        if: github.event_name == 'pull_request'
        uses: tj-actions/changed-files@v17.3
        with:
          separator: ","
          files_ignore: |
            .github/**
          files: |
            packages/**
      - name: setup python
        uses: actions/setup-python@v2
        with:
          python-version: 3.8 #install the python needed
      - name: create service build list
        id: build_list
        env:
          CHANGED_FILES_PR: ${{ steps.changed-files-pr.outputs.all }}
          CHANGED_FILES_NOT_PR: ${{ steps.changed-files-not-pr.outputs.all }}
        run: |
          pwd
          ls
          echo "GITHUB_WORKSPACE: $GITHUB_WORKSPACE"
          python .github/workflows/scripts/get-service-build-list.py
          service_build_list=$(cat $GITHUB_WORKSPACE/service_build_list.json)
          echo "service_build_list: $service_build_list"
          echo "::set-output name=service_build_list::$service_build_list"
      # - name: Filter array
      #   id: filter
      #   env:
      #     ARRAY: ${{ steps.changed-files.outputs.all_changed_files }}
      #   run: |
      #     if [[ ! -z $ARRAY ]]
      #     then 
      #       echo "$ARRAY"
      #       final=''
      #       for string in $(echo $ARRAY | sed "s/,/ /g")
      #       do
      #         prefix="packages/"
      #         no_prefix=${string#"$prefix"}
      #         final+="\"$( cut -d '/' -f 1 <<< "$no_prefix" )\", "
      #       done
      #       final+=''
      #       mod=$(echo $final | tr ' ' '\n' | sort | uniq | tr '\n' ' ' | sed -e 's/[[:space:]]*$//')
      #       modi=${mod%?}
      #       modif=[$(echo "$modi")]
      #       echo $modif
      #       echo "::set-output name=array::$modif"
      #     else
      #       final=''
      #       for d in packages/*
      #       do
      #         prefix="packages/"
      #         no_prefix=${d#"$prefix"}
      #         final+="\"$( cut -d '/' -f 1 <<< "$no_prefix" )\", "
      #       done
      #       mod=$(echo $final | tr ' ' '\n' | sort | uniq | tr '\n' ' ' | sed -e 's/[[:space:]]*$//')
      #       modi=${mod%?}
      #       modif=[$(echo "$modi")]
      #       echo $modif
      #       echo "::set-output name=array::$modif"
      #     fi

      # - name: Filter services from array
      #   id: filter-services
      #   env:
      #     ARRAY: ${{ steps.filter.outputs.array }}
      #   run: |
      #       services=['"amplication-client", "amplication-server"']
      #       echo "$services"
      #       echo "::set-output name=array::$services"

      # - name: Resolve changed packages
      #   id: resolved-packages
      #   run: |
      #     echo ::set-output name=packages::$( \

      #     # Git Diff - Get all changed files
      #     git diff --name-only origin/master -- 'packages/**' |

      #     # Extract package names from files path
      #     grep -Po 'packages/\K[^/]*' |

      #     # Dupplication
      #     sort -t: -u -k1,1 |

      #     # Format, Example: amplication-cli => package:@amplication/cli:path:amplication-cli
      #     sed -e "s/amplication-\(.*\)/package:@amplication\/\1:path:packages\/amplication-\1/" |

      #     # Create array of objects, => [{"package": "@amplication/cli", "path": "amplication-cli"}]
      #     jq -Rs 'split("\n")|map(split(":")|{(.[0]):.[1],(.[2]):.[3]}?)')

      - name: download folder if service not changed 
        run: |
          set +e
          unupdated_services=()
          if [[ ! " ${{ needs.changes.outputs.services }}[*] " =~ "amplication-server" ]]; then
            unupdated_services+=("amplication-server")
          fi
          if [[ ! " ${{ needs.changes.outputs.services }}[*] " =~ "amplication-client" ]]; then
            unupdated_services+=("amplication-client")
          fi
          echo $unupdated_services
      # - name: Filter services from array
      #   id: filter-services
      #   env:
      #     ARRAY: ${{ steps.filter.outputs.array }}
      #   run: |
      #     if [[ ! -z $ARRAY ]]
      #     then 
      #       echo "$ARRAY"
      #       services=()
      #       if [[ " ${ARRAY[*]} " =~ "amplication-client" ]]; then
      #         echo amplication-client in ARRAY 
      #         services+=('amplication-client') 
      #       fi
      #       if [[ " ${ARRAY[*]} " =~ "amplication-server" ]]; then
      #         echo amplication-server in ARRAY 
      #         services+=('amplication-server') 
      #       fi
      #       echo services : ${services[*]}
      #       echo "::set-output name=array::$services"
      #     else
      #       echo "array is empty, no files changed"
      #     fi


  # test:
  #   runs-on: ubuntu-latest
  #   needs: [changes]
  #   if: ${{ needs.changes.outputs.services != '[]' && needs.changes.outputs.services != '' }}
  #   strategy:
  #     matrix:
  #       node-version: [16.x]
  #       service: ${{ fromJSON(needs.changes.outputs.services) }} 

  #   steps:
  #   - name: Checkout repository
  #     uses: actions/checkout@v2

  #   - name: Check docker-service
  #     id: check-docker-service
  #     env: 
  #       SERVICE: ${{ matrix.service }}
  #     run: |
  #       FILE=packages/$SERVICE/Dockerfile
  #       if [[ -f "$FILE" ]] 
  #       then
  #         echo "$FILE exists."
  #         echo "::set-output name=docker-service::true"
  #       else
  #         echo "::set-output name=docker-service::false"
  #       fi

  #   - name: Use Node.js ${{ matrix.node-version }}
  #     uses: actions/setup-node@v2
  #     with:
  #       node-version: ${{ matrix.node-version }}
  #       cache: 'npm'
        
  #   - name: "Install dependencies ${{ matrix.service }}"
  #     if: ${{ steps.check-docker-service.outputs.docker-service == 'true' }}
  #     run: npm ci
  # - name: "Test first run: ${{ matrix.service }}"
  #     continue-on-error: true
  #     if: ${{ steps.check-docker-service.outputs.docker-service == 'true' }}
  #     working-directory: packages/${{ matrix.service }}
  #     run: npm test
    

  tests:
    runs-on: ubuntu-20.04
    needs:
      - changes
    timeout-minutes: 45
    strategy:
      matrix:
        package: ${{ fromJson(needs.changes.outputs.packages) }}
        node-version: [14.x, 16.x]
    steps:
      - uses: actions/checkout@v2

      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node-version }}
      - name: Cache node modules
        uses: actions/cache@v2
        with:
          path: |
            ~/.npm
            node_modules
            */*/node_modules
          key: PUSH-${{ runner.os }}-${{matrix.node-version}}-${{matrix.package.package}}-${{ hashFiles(format('{0}/package-lock.json',matrix.package.path)) }}
          restore-keys: |
            PUSH-${{ runner.os }}-${{matrix.node-version}}-${{matrix.package.package}}-
            PUSH-${{ runner.os }}-${{matrix.node-version}}-
            PUSH-${{ runner.os }}-

      - name: Install Node.js dependencies
        run: npm ci --cache ~/.npm --prefer-offline --only=production --silent

      - name: Install package dependencies
        id: install
        run: lerna bootstrap --scope=${{matrix.package.package}} --include-dependencies

      - name: Build Prisma client
        id: prisma
        run: lerna run --scope=${{matrix.package.package}} prisma:generate

      - name: Build code
        id: build
        run: lerna run --scope=${{matrix.package.package}} --loglevel=silent build --include-dependencies

      - name: Format code
        id: format
        run: lerna run --scope=${{matrix.package.package}} --loglevel=silent check-format

      - name: Lint code
        id: lint
        run: lerna run --scope=${{matrix.package.package}} --loglevel=silent lint

      - name: Run tests
        id: test
        run: lerna run --scope=${{matrix.package.package}} --loglevel=silent test

      - name: Discord notification
        if: failure()
        uses: Ilshidur/action-discord@0.3.2
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_BUILD_NOTIFICATIONS_CHANNEL_WEBHOOK }}
          DISCORD_EMBEDS: '[{"color":15734528,"title":"Push Validation Failed - ${{ github.ref_name }}","url":"https://github.com/${{github.repository}}/actions/runs/${{github.run_id}}","description":"Job ${{ github.job }} in workflow ${{ github.workflow }} failed!","fields":[{"name":"Package","value":"${{ matrix.package.package }}"},{"name":"Commiter","value":"${{ github.event.pusher.name }}"},{"name":"Commit","value":"${{ github.event.head_commit.id }}"},{"name":"Install","value":"${{ steps.install.outcome }}","inline":true},{"name":"Build","value":"${{ steps.build.outcome }}","inline":true},{"name":"Test","value":"${{ steps.test.outcome }}","inline":true},{"name":"Format","value":"${{ steps.format.outcome }}","inline":true},{"name":"Lint","value":"${{ steps.lint.outcome }}","inline":true}]}]'

  # tests:
  #   runs-on: ubuntu-latest
  #   needs: [changes]
  #   # if: ${{ needs.changes.outputs.services != '[]' && needs.changes.outputs.services != '' }}
  #   strategy:
  #     matrix:
  #       node-version: [16.x]
  #       service: ${{ fromJSON(needs.changes.outputs.services) }} 

  #   steps:
  #   - name: Checkout repository
  #     uses: actions/checkout@v2

  #   # - name: Check docker-service
  #   #   id: check-docker-service
  #   #   env: 
  #   #     SERVICE: ${{ matrix.service }}
  #   #   run: |
  #   #     FILE=packages/$SERVICE/Dockerfile
  #   #     if [[ -f "$FILE" ]] 
  #   #     then
  #   #       echo "$FILE exists."
  #   #       echo "::set-output name=docker-service::true"
  #   #     else
  #   #       echo "::set-output name=docker-service::false"
  #   #     fi

  #   - name: set branch-name
  #     run: |
  #       if [[ $GITHUB_REF != 'refs/heads/master' ]]
  #       then 
  #         echo "BRANCH_NAME=$(echo $GITHUB_REF_NAME | sed "s/\//-/g")" >> $GITHUB_ENV
  #       fi
  

  #   - name: download folder if service not changed 
  #     run: |
  #       set +e
  #       unupdated_services=()
  #       if [[ ! " ${{ needs.changes.outputs.services }}[*] " =~ "amplication-server" ]]; then
  #         unupdated_services+=("amplication-server")
  #       fi
  #       if [[ ! " ${{ needs.changes.outputs.services }}[*] " =~ "amplication-client" ]]; then
  #         unupdated_services+=("amplication-client")
  #       fi
  #       echo $unupdated_services


  #   - name: install python dependencies
  #     run: |
  #       pip install ruamel.yaml
  #       pip install pytest-shutil


  #   - name: replace helm version to run_id
  #     run: |
  #       python devlopment_scripts/update_helm_versions.py ${GITHUB_RUN_ID} ${BRANCH_NAME} "${{ needs.changes.outputs.services }}"

  #   - name: Use Node.js ${{ matrix.node-version }}
  #     uses: actions/setup-node@v2
  #     with:
  #       node-version: ${{ matrix.node-version }}
  #       cache: 'npm'

  #   - name: print node env
  #     run: |
  #       echo $NODE_ENV
        
  #   - name: "Install dependencies ${{ matrix.service }}"
  #     run: npm ci

  #   - name: "Test first run: ${{ matrix.service }}"
  #     working-directory: packages/${{ matrix.service }}
  #     run: npm test

  #   - name: "Check format: ${{ matrix.service }}"
  #     working-directory: packages/${{ matrix.service }}
  #     run: npm run check-format

  #   - name: "Lint first run: ${{ matrix.service }}"
  #     working-directory: packages/${{ matrix.service }}
  #     run: npm run lint
  
  docker:
    name: docker
    needs: [changes,tests]
    if: always() && success() #&& (github.event_name == 'push')
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [16.x]
        service: ${{ fromJSON(needs.changes.outputs.services) }} 

    steps:
      - name: Checkout
        uses: actions/checkout@v2
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1
            
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }} 
          aws-region: us-east-1
          
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Set hash
        env:
          working-directory: packages/${{ matrix.service }}/Dockerfile
        run: |
          GITHUB_HASH_MOD=$(sha1sum packages/${{ matrix.service }}/Dockerfile | sha1sum)
          echo "GITHUB_HASH=${GITHUB_HASH_MOD%???}" >> $GITHUB_ENV
       
      - name: Check if repo exist
        working-directory: packages/${{ matrix.service }}
        env: 
          ECR_REPOSITORY_STAGING: ${{ matrix.service }}-staging
          ECR_REPOSITORY_PROD: ${{ matrix.service }}-prod
        run: |
          if [[ $GITHUB_REF != 'refs/heads/master' ]]
          then 
            aws ecr describe-repositories --repository-names $ECR_REPOSITORY_STAGING || aws ecr create-repository --repository-name $ECR_REPOSITORY_STAGING
          else
            aws ecr describe-repositories --repository-names $ECR_REPOSITORY_PROD || aws ecr create-repository --repository-name $ECR_REPOSITORY_PROD
          fi

      - name: Check if tag already exist
        id: tag-exist
        env: 
          ECR_REPOSITORY_STAGING: ${{ matrix.service }}-staging
          ECR_REPOSITORY_PROD: ${{ matrix.service }}-prod
        run: |
          set +e
          if [[ $GITHUB_REF != 'refs/heads/master' ]]
          then 
            cmd="$(aws ecr describe-images --repository-name=$ECR_REPOSITORY_STAGING --image-ids=imageTag=$GITHUB_HASH)"
          else
            cmd="$(aws ecr describe-images --repository-name=$ECR_REPOSITORY_PROD --image-ids=imageTag=$GITHUB_HASH)"
          fi
          if [[ ! -z "$cmd" ]]
          then  
            echo "tag already exist"
            echo "::set-output name=tag_exist::true"
          else
            echo "tag doesn't exist"
            echo "::set-output name=tag_exist::false"
          fi
      
      - name: set branch-name
        run: |
          if [[ $GITHUB_REF != 'refs/heads/master' ]]
          then 
            echo "BRANCH_NAME=$(echo $GITHUB_REF_NAME | sed "s/\//-/g")" >> $GITHUB_ENV
          fi

      - name: Build, tag, and push image to Amazon ECR
        if: ${{ steps.tag-exist.outputs.tag_exist == 'false' }}
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY_STAGING: ${{ matrix.service }}-staging
          ECR_REPOSITORY_PROD: ${{ matrix.service }}-prod
        run: |
          if [[ $GITHUB_REF != 'refs/heads/master' ]]
          then
            Docker_image=$ECR_REGISTRY/$ECR_REPOSITORY_STAGING:$GITHUB_HASH
            Ecr_repository=$ECR_REPOSITORY_STAGING
          else  
            Docker_image=$ECR_REGISTRY/$ECR_REPOSITORY_PROD:$GITHUB_HASH
            ECR_repository=$ECR_REPOSITORY_PROD
          fi
          echo $Ecr_repository
          docker build -f ./packages/${{ matrix.service }}/Dockerfile . -t $Docker_image
          docker push $Docker_image
          MANIFEST=$(aws ecr batch-get-image --repository-name $ECR_repository --image-ids imageTag=$GITHUB_HASH --output json | jq --raw-output --join-output '.images[0].imageManifest')
          aws ecr put-image --repository-name $ECR_repository --image-tag ${{ github.sha }} --image-manifest "$MANIFEST"
          aws ecr put-image --repository-name $ECR_repository --image-tag ${{ github.ref_name }} --image-manifest "$MANIFEST"
          aws ecr put-image --repository-name $ECR_repository --image-tag ${{ github.run_id }} --image-manifest "$MANIFEST"
          
          
  service-chart:
    runs-on: ubuntu-latest
    needs: [docker,changes,tests]
    env:
      BUCKET_NAME: amplication-charts
      REGION: us-east-1
      SERVICE_CHART_PATH: helm/helm_chart/charts/services
    strategy:
      matrix:
        service: ${{ fromJSON(needs.changes.outputs.services) }} 
    steps:
      - name: Checkout
        uses: actions/checkout@v2

      # - name: download folder if service not changed 
      #   run: |
      #     set +e
            # if [[ ! " ${{ needs.changes.outputs.services }}[*] " =~ "amplication-server" ]]; then
            #   server_folder=$(aws s3 ls "s3://$BUCKET_NAME/$BRANCH_NAME/amplication-server")
            #   if [[ ! -z "$server_folder" ]]; then    
            #     KEY=`aws s3 ls "s3://$BUCKET_NAME/$BRANCH_NAME/amplication-server" --recursive | sort | tail -n 1 | awk '{print $4}'`
            #     aws s3 sync s3://$BUCKET_NAME/$BRANCH_NAME/amplication-server/$KEY ./downloaded_helms
            #   fi
            #   else
            #     server_folder=$(aws s3 ls "s3://$BUCKET_NAME/master/amplication-server")
            #     if [[ ! -z "$server_folder" ]]; then    
            #       KEY=`aws s3 ls "s3://$BUCKET_NAME/master/amplication-server" --recursive | sort | tail -n 1 | awk '{print $4}'`
            #       aws s3 sync s3://$BUCKET_NAME/master/amplication-server/$KEY /downloaded_helms/amplication-server
            #     fi
            #     else
            #       cp helm/helm_chart/charts/services/amplication-server /downloaded_helms/amplication-server
            #     fi
            #   fi
            # fi
            # if [[ ! " ${{ needs.changes.outputs.services }}[*] " =~ "amplication-client" ]]; then
            #   server_folder=$(aws s3 ls "s3://$BUCKET_NAME/$BRANCH_NAME/amplication-client")
            #   if [[ ! -z "$server_folder" ]]; then    
            #     KEY=`aws s3 ls "s3://$BUCKET_NAME/$BRANCH_NAME/amplication-client" --recursive | sort | tail -n 1 | awk '{print $4}'`
            #     aws s3 sync s3://$BUCKET_NAME/$BRANCH_NAME/amplication-client/$KEY ./downloaded_helms
            #   fi
            #   else
            #     server_folder=$(aws s3 ls "s3://$BUCKET_NAME/master/amplication-client")
            #     if [[ ! -z "$server_folder" ]]; then    
            #       KEY=`aws s3 ls "s3://$BUCKET_NAME/master/amplication-client" --recursive | sort | tail -n 1 | awk '{print $4}'`
            #       aws s3 sync s3://$BUCKET_NAME/master/amplication-client/$KEY /downloaded_helms/amplication-client
            #     fi
            #     else
            #       cp helm/helm_chart/charts/services/amplication-client /downloaded_helms/amplication-client
            #     fi
            #   fi
            # fi


      - name: install python dependencies
        run: |
          pip install ruamel.yaml
          pip install pytest-shutil


      - name: replace helm version to run_id
        run: |
          python devlopment_scripts/update_helm_versions.py ${GITHUB_RUN_ID} ${{ needs.changes.outputs.services }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} 
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }} 
          aws-region: ${{ env.REGION }}

      - name: set branch-name
        run: |
          if [[ $GITHUB_REF != 'refs/heads/master' ]]
          then 
            echo "BRANCH_NAME=$(echo $GITHUB_REF_NAME | sed "s/\//-/g")" >> $GITHUB_ENV
          fi

      - name: Check service folder exist
        id: check_folder
        run: |
          set +e
          server_folder=$(aws s3 ls "s3://$BUCKET_NAME/$BRANCH_NAME/${{ matrix.service }}")
          if [[ -z "$server_folder" ]]
          then
            echo "No such folder in bucket"
            echo "::set-output name=create_folder::true"
          else
            echo "folder exist in bucket"
            echo "::set-output name=create_folder::false"
          fi

      - name: Update dependencies for service chart
        working-directory: ${{ env.SERVICE_CHART_PATH }}/${{ matrix.service }}
        run: |
          helm dependency update

      - name: Helm Template
        working-directory: ${{ env.SERVICE_CHART_PATH }}/${{ matrix.service }}
        id: helm-template
        run: |
          helm template amplication . > helm.log
      
      - env:
          TEMPLATES: "helm template\n${{ steps.helm-template.outputs.stdout }}"
        run: echo ${TEMPLATES}

      - name: Set hash
        env:
          working-directory: ${{ env.SERVICE_CHART_PATH }}/${{ matrix.service }}
        run: |
          GITHUB_HASH_MOD=$(sha1sum $working-directory | sha1sum)
          echo "GITHUB_HASH=${GITHUB_HASH_MOD%???}" >> $GITHUB_ENV
      
      - name: replace image tag in values.yml
        run: |
          python devlopment_scripts\update_tag.py ${GITHUB_HASH} ${{ matrix.service }}
      
      - name: Upload artifact to s3
        working-directory: ${{ env.SERVICE_CHART_PATH }}
        run: |
          set +e
          if [[ ${{ steps.check_folder.outputs.create_folder == 'true' }} ]]
          then
            pwd
            tar -cvzf ${{ matrix.service }}_$GITHUB_HASH.tgz ./${{ matrix.service }}
            ls -l
            aws s3 cp ${{ matrix.service }}_$GITHUB_HASH.tgz s3://$BUCKET_NAME/${{ matrix.service }}/${{ matrix.service }}_$GITHUB_HASH.tgz
          else
            pwd
            tar -cvzf ${{ matrix.service }}_$GITHUB_HASH.tgz ./${{ matrix.service }}
            ls -l
            isTagExist=$(aws s3 ls s3://BUCKET-NAME/${{ matrix.service }} --recursive | grep ${{ matrix.service }}_$GITHUB_HASH.tgz)
            if [[ ! -z  "$isTagExist" ]]
            then 
              aws s3 cp ${{ matrix.service }}_$GITHUB_HASH.tgz s3://$BUCKET_NAME/${{ matrix.service }}/${{ matrix.service }}_$GITHUB_HASH.tgz
            fi
          fi

  umbrella-chart:
    runs-on: ubuntu-latest
    needs: service-chart
    env:
      BUCKET_NAME: amplication-charts
      REGION: us-east-1
      AMPLICATION_CHART_PATH: amplication/chart/amplication
      SERVICE_CHART_PATH: amplication-charts/charts/services

    steps:
      - name: Checkout
        uses: actions/checkout@v2
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} 
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }} 
          aws-region: ${{ env.REGION }}
      
      - name: Check amplication folder exist
        id: check_folder
        env:
          last_artifact: ${{ steps.last_artifact.outputs.service_artifact }}
        run: |
          set +e
          amplication_folder=$(aws s3 ls "s3://$BUCKET_NAME/amplication")
          if [[ -z "$amplication_folder" ]]
          then
            echo "No such folder in bucket"
            echo "::set-output name=create_folder::true"
          else
            echo "folder exist in bucket"
            echo "::set-output name=create_folder::false"
          fi

      - name: Helm Update Dependencies for umbrella-chart
        working-directory: ${{ env.AMPLICATION_CHART_PATH }}
        run: |
          helm dependency update

      - name: Helm Template
        working-directory: ${{ env.AMPLICATION_CHART_PATH }}
        id: helm-template
        run: |
          helm template amplication . > helm.log
      
      - env:
          TEMPLATES: "helm template\n${{ steps.helm-template.outputs.stdout }}"
        run: echo ${TEMPLATES}
      
      - name: Upload artifact to s3
        working-directory: ${{ env.AMPLICATION_CHART_PATH }}
        env:
          last_artifact: ${{ steps.last_artifact.outputs.amplication_artifact }}
        run: |
          set +e
          if [[ ${{ steps.check_folder.outputs.create_folder == 'true' }} ]]
          then
            pwd
            tar -cvzf amplication_$GITHUB_RUN_ID.tgz ./
            ls -l
            aws s3 cp amplication_$GITHUB_RUN_ID.tgz s3://$BUCKET_NAME/amplication_/amplication__$GITHUB_RUN_ID.tgz
          else
            pwd
            tar -cvzf amplication_$GITHUB_RUN_ID.tgz ./
            ls -l
            isTagExist=$(aws s3 ls s3://BUCKET-NAME/amplication_ --recursive | grep amplication__$GITHUB_RUN_ID.tgz)
            if [[ ! -z  "$isTagExist" ]]
            then 
              aws s3 cp amplication_$GITHUB_RUN_ID.tgz s3://$BUCKET_NAME/amplication_/amplication__$GITHUB_RUN_ID.tgz
            fi
          fi






 
      


      



